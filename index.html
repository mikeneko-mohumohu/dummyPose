<html>
  <head>
    <meta charset="utf-8"/>
    <!-- Load TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@0.11.7"></script>
    <!-- Load Posenet -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/posenet@0.1.2"></script>
    <!-- THREE JS -->
    <script src="js/three.min.js"></script>
    <script src="js/OrbitControls.js"></script>
  </head>

  <body>    
    <video id="camera" playsinline style="-moz-transform: scaleX(-1); -o-transform: scaleX(-1); -webkit-transform: scaleX(-1); transform: scaleX(-1); display: none;"></video>
    <!-- 記録用canvas -->
    <canvas id="camera-canvas"></canvas>
    <!-- 3D用canvas -->
    <canvas id="canvas" ></canvas>
</body>

<script>
var rightShoulder ={x:0,y:0}
var rightElbow={x:0,y:0}
var rightWrist={x:0,y:0}
const videoWidth = 500;
const videoHeight = 500;
//----- ここから３D描画 -----//
function init() {
  var width = videoWidth;
  var height = videoHeight;
  var renderer = new THREE.WebGLRenderer({
    canvas: document.getElementById("canvas"),
    alpha: false,
    antialias: true
  });
  renderer.setClearColor(0xf3f3f3,1.0);
  renderer.setSize(width,height);

  var scene = new THREE.Scene();
  
  ambient = new THREE.AmbientLight(0xeeeeee,1);
  scene.add(ambient);
  var gridHelper = new THREE.GridHelper(200,5);
  scene.add(gridHelper);
  var axisHelper = new THREE.AxesHelper(300);
  //scene.add(axisHelper);

  var controlCamera = new THREE.PerspectiveCamera(45, width / height, 1, 4000);
  controlCamera.position.set(0,10,100);
  var controls = new THREE.OrbitControls(controlCamera);



  var armGeometry = new THREE.CylinderGeometry(5,5,40,3,2,true);
  armGeometry.bones = [{
    name: "bone0",
    parent: 1,
    pos: [0, -15, 0],
    rotq: [0, 0, 0, 1],
    scl: [1, 1, 1],
  },
  {
    name: "bone1",
    parent: 2,
    pos: [0, -25, 0],
    rotq: [0, 0, 0, 1],
    scl: [1, 1, 1],
  },
  {
    name: "bone2",
    parent: -1,
    pos: [0, 20, 0],
    rotq: [0, 0, 0, 1],
    scl: [1, 1, 1],
  }
  ];

  armGeometry.skinIndices = [
  new THREE.Vector4(2, -1,  -1, -1), new THREE.Vector4(2, -1,  -1, -1), new THREE.Vector4(2, -1,  -1, -1),
  new THREE.Vector4(1, 2,  -1, -1), new THREE.Vector4(1, 2,  -1, -1), new THREE.Vector4(1, 2,  -1, -1),
  new THREE.Vector4(0, 1, -1, -1), new THREE.Vector4(0, 1, -1, -1), new THREE.Vector4(0, 1, -1, -1),
  ]

  armGeometry.skinWeights = [
  new THREE.Vector4(.10, .0,  0, 0), new THREE.Vector4(.10, .0,  0, 0), new THREE.Vector4(.10, .0,  0, 0),
  new THREE.Vector4(.6, .4,  0, 0), new THREE.Vector4(.6, .4,  0, 0), new THREE.Vector4(.6, .4,  0, 0),
  new THREE.Vector4(.6, .4, .0, 0), new THREE.Vector4(.6, .4, .0, 0), new THREE.Vector4(.6, .4, .0, 0),
];

  var armMaterial = new THREE.MeshNormalMaterial({
    skinning: true,
    side: THREE.DoubleSide,
    flatShading: THREE.FlatShading,
  });

  var arm = new THREE.SkinnedMesh(armGeometry,armMaterial);
  var skeletonHelper = new THREE.SkeletonHelper(arm);
  skeletonHelper.material.linewidth = 10;

  scene.add(arm);
  scene.add(skeletonHelper);

  function animate(time) {
    requestAnimationFrame(animate);
    render(time);
  }

  var lastTime = 0;

  function render() {
    controls.update();
    var time = new Date();
    //arm.rotation.y += (time - lastTime) * 0.0002;
    arm.skeleton.bones[0].position.x = (rightElbow.x - rightWrist.x)/10;
    arm.skeleton.bones[1].position.x = (rightShoulder.x - rightElbow.x)/10;
    arm.skeleton.bones[2].position.x = (rightShoulder.x)/10;
    arm.skeleton.bones[0].position.y = (rightElbow.y - rightWrist.y)/10;
    arm.skeleton.bones[1].position.y = (rightShoulder.y - rightElbow.y)/10;
    arm.skeleton.bones[2].position.y = (rightShoulder.y)/10;

    console.log(arm.skeleton.bones[0].position)
    //console.log(arm.skeleton.bones[1].position)
    //console.log(arm.skeleton.bones[2].position)

//    arm.skeleton.bones[2].rotation.x = Math.sin(time * 0.002) * .5;

    renderer.render(scene, controlCamera);
    lastTime = time;
  }

  animate()
}

init();




//----- ここから骨取得 -----//
const color = "aqua";
const lineWidth = 2;

async function setupCamera() {
    const video = document.getElementById('camera');
    video.width = videoWidth;
　  video.height = videoHeight;
    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        const stream = await navigator.mediaDevices.getUserMedia({
          'audio': false,
          'video': {
            facingMode: 'user',
            width: videoWidth,
            height: videoHeight}
        });
    video.srcObject = stream;
    
    return new Promise(resolve => {
      video.onloadedmetadata = () => {
        resolve(video);
      };
    });
    } else {
      const errorMessage = "This browser does not support video capture, or this device does not have a camera";
      alert(errorMessage);
      return Promise.reject(errorMessage);
  }
}


function takePicture(video, net) {
    const canvas = document.getElementById('camera-canvas');
    canvas.width = videoWidth;
    canvas.height = videoHeight;
    const ctx = canvas.getContext('2d');
    
    const imageScaleFactor = 0.5;
    const flipHorizontal = false;
    const outputStride = 16;
    const minPoseConfidence = 0.1;
    const minPartConfidence = 0.5;

    async function poseDetectionFrame() {
        let poses = [];
        var date = new Date();
        
        const pose = await net.estimateSinglePose(video, imageScaleFactor, flipHorizontal, outputStride);
        poses.push(pose);

        ctx.clearRect(0, 0, videoWidth, videoHeight);

        ctx.save();
// 鏡にしたい場合
//        ctx.scale(-1, 1);
//        ctx.translate(-videoWidth, 0);

// カメラ写す場合　今回は骨さえ取れればいいのでいらん
//        ctx.drawImage(video, 0, 0, videoWidth, videoHeight);

ctx.fillStyle = "rgb(200,0,0)";
ctx.fillRect(0,0,videoWidth,videoHeight);
        ctx.restore();


        // For each pose (i.e. person) detected in an image, loop through the poses
        // and draw the resulting skeleton and keypoints if over certain confidence
        // scores
        
        poses.forEach(({ score, keypoints }) => {
            if (score >= minPoseConfidence) {
              drawKeypoints(keypoints, minPartConfidence, ctx);
              drawSkeleton(keypoints, minPartConfidence, ctx);
          }
        });
    
    // End monitoring code for frames per second

        requestAnimationFrame(poseDetectionFrame);
    }

  poseDetectionFrame();
}

function drawKeypoints(keypoints, minConfidence, ctx, scale = 1) {
  for (let i = 0; i < keypoints.length; i++) {
    const keypoint = keypoints[i];

    if (keypoint.part == "rightShoulder"){rightShoulder = keypoint.position}
    if(keypoint.part == "rightElbow"){rightElbow = keypoint.position}
    if(keypoint.part == "rightWrist"){rightWrist = keypoint.position}
      

    if (keypoint.score < minConfidence) {
      continue;
    }

    const { y, x } = keypoint.position;
    ctx.beginPath();
    ctx.arc(x * scale, y * scale, 3, 0, 2 * Math.PI);
    ctx.fillStyle = color;
    ctx.fill();

  }
}

function toTuple({ y, x }) {
  return [y, x];
}

function drawSkeleton(keypoints, minConfidence, ctx, scale = 1) {
  const adjacentKeyPoints = posenet.getAdjacentKeyPoints(
    keypoints, minConfidence);

  adjacentKeyPoints.forEach((keypoints) => {
    drawSegment(toTuple(keypoints[0].position),
      toTuple(keypoints[1].position), color, scale, ctx);
  });
}

function drawSegment([ay, ax], [by, bx], color, scale, ctx) {
  ctx.beginPath();
  ctx.moveTo(ax * scale, ay * scale);
  ctx.lineTo(bx * scale, by * scale);
  ctx.lineWidth = lineWidth;
  ctx.strokeStyle = color;
  ctx.stroke();
}

async function loadVideo() {
  const video = await setupCamera();
  video.play();

  return video;
}

async function main(){
    const net = await posenet.load();

    let video;
    video = await loadVideo();
    
    takePicture(video, net);
}

main();

  </script>
</html>