<html>
  <head>
    <meta charset="utf-8"/>
    <!-- Load TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@0.11.7"></script>
    <!-- Load Posenet -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/posenet@0.1.2"></script>
    <!-- THREE JS -->
    <script src="js/three.min.js"></script>
    <script src="js/OrbitControls.js"></script>
  </head>

  <body>    
    <video id="camera" playsinline style="-moz-transform: scaleX(-1); -o-transform: scaleX(-1); -webkit-transform: scaleX(-1); transform: scaleX(-1); display: none;"></video>
    <!-- 記録用canvas -->
    <canvas id="camera-canvas"></canvas>
    <!-- 3D用canvas -->
    <canvas id="canvas" ></canvas>
</body>

<script>
var nowRightShoulderToElbow = 0;
var nowLeftShoulderToElbow = 0;
var maxRightShoulderToElbow = 1;
var maxLeftShoulderToElbow = 1;

var rightShoulder ={x:0,y:0}
var rightElbow={x:0,y:0}
var rightWrist={x:0,y:0}

var leftShoulder ={x:0,y:0}
var leftElbow={x:0,y:0}
var leftWrist={x:0,y:0}

var rightHip ={x:0,y:0}
var leftHip ={x:0,y:0}

var centerBody={x:0,y:0}

const videoWidth = 500;
const videoHeight = 500;
//----- ここから３D描画 -----//
function init() {
  var width = videoWidth;
  var height = videoHeight;
  var renderer = new THREE.WebGLRenderer({
    canvas: document.getElementById("canvas"),
    alpha: false,
    antialias: true
  });
  renderer.setClearColor(0xf3f3f3,1.0);
  renderer.setSize(width,height);

  var clock = new THREE.Clock();
  var scene = new THREE.Scene();
  
  ambient = new THREE.AmbientLight(0xeeeeee,1);
  scene.add(ambient);
  var gridHelper = new THREE.GridHelper(200,5);
  scene.add(gridHelper);
  var axisHelper = new THREE.AxesHelper(300);
  //scene.add(axisHelper);

  var controlCamera = new THREE.PerspectiveCamera(45, width / height, 1, 4000);
  controlCamera.position.set(0,10,100);
  var controls = new THREE.OrbitControls(controlCamera);



  var armGeometry = new THREE.CylinderGeometry(5,5,40,3,2,true);
  armGeometry.bones = [{
    name: "bone0",
    parent: 1,
    pos: [0, -15, 0],
    rotq: [0, 0, 0, 1],
    scl: [1, 1, 1],
  },
  {
    name: "bone1",
    parent: 2,
    pos: [0, -25, 0],
    rotq: [0, 0, 0, 1],
    scl: [1, 1, 1],
  },
  {
    name: "bone2",
    parent: -1,
    pos: [0, 20, 0],
    rotq: [0, 0, 0, 1],
    scl: [1, 1, 1],
  }
  ];

  armGeometry.skinIndices = [
  new THREE.Vector4(2, -1,  -1, -1), new THREE.Vector4(2, -1,  -1, -1), new THREE.Vector4(2, -1,  -1, -1),
  new THREE.Vector4(1, 2,  -1, -1), new THREE.Vector4(1, 2,  -1, -1), new THREE.Vector4(1, 2,  -1, -1),
  new THREE.Vector4(0, 1, -1, -1), new THREE.Vector4(0, 1, -1, -1), new THREE.Vector4(0, 1, -1, -1),
  ]

  armGeometry.skinWeights = [
  new THREE.Vector4(.10, .0,  0, 0), new THREE.Vector4(.10, .0,  0, 0), new THREE.Vector4(.10, .0,  0, 0),
  new THREE.Vector4(.6, .4,  0, 0), new THREE.Vector4(.6, .4,  0, 0), new THREE.Vector4(.6, .4,  0, 0),
  new THREE.Vector4(.6, .4, .0, 0), new THREE.Vector4(.6, .4, .0, 0), new THREE.Vector4(.6, .4, .0, 0),
];

  var armMaterial = new THREE.MeshNormalMaterial({
    skinning: true,
    side: THREE.DoubleSide,
    flatShading: THREE.FlatShading,
  });

  var arm = new THREE.SkinnedMesh(armGeometry,armMaterial);
  var skeletonHelper = new THREE.SkeletonHelper(arm);
  skeletonHelper.material.linewidth = 10;

  //scene.add(arm);
  //scene.add(skeletonHelper);
  var character;
  var mixer;
  var action = {};
  var textureLoader = new THREE.TextureLoader();
  textureLoader.load('./model/fox.png',
    texture => {
      var material = new THREE.MeshBasicMaterial({
        map: texture,
        skinning: true,// これ忘れないよう注意　スキンとボーンの追従
      });

      var loader = new THREE.JSONLoader();
      loader.load('./model/fox.json', function(geometry) {
        character = new THREE.SkinnedMesh(geometry, material);
/*
        var characterSkeletonHelper = new THREE.SkeletonHelper(character);
        characterSkeletonHelper.material.linewidth = 10;
        scene.add(characterSkeletonHelper);
*/
        character.position.set(0,0,0);
        character.scale.set(20,20,20);
        scene.add(character);        
        
        mixer = new THREE.AnimationMixer(character);
        action.walk = mixer.clipAction(geometry.animations[1]);
//        action.walk.play();

        animate();
      });
    }
  );


  function animate(time) {
    requestAnimationFrame(animate);
    render(time);
  }

  var lastTime = 0;

  function render() {
    controls.update();
    var time = new Date();
    //arm.rotation.y += (time - lastTime) * 0.0002;
//    console.log(character.skeleton.bones[10].rotation);    
    //character.skeleton.bones[10].rotation.z = Math.sin(rightShoulder.y - rightElbow.y * 0.002) * 0.5;

    var rightRag = Math.sin(Math.atan2(rightElbow.y - rightShoulder.y, rightElbow.x - rightShoulder.x))+1;
    var leftRag = Math.sin(Math.atan2(leftElbow.y - leftShoulder.y, leftElbow.x - leftShoulder.x))+1;
//    console.log(maxRightShoulderToElbow);
//  console.log(Math.sin(Math.atan2(rightElbow.y - rightShoulder.y, rightElbow.x - rightShoulder.x) + 90));
  //character.skeleton.bones[10].rotation.x = -1* rightRag;
  //character.skeleton.bones[8].rotation.x = leftRag;

  var leftCos = nowLeftShoulderToElbow / maxLeftShoulderToElbow
  var rightCos = nowRightShoulderToElbow / maxRightShoulderToElbow
  character.skeleton.bones[8].rotation.z = (leftCos > 0)?-3.25 * leftCos: -3.25 - 3.25 * leftCos;
  character.skeleton.bones[10].rotation.z = (rightCos > 0)?-3.25 + 3.25 * rightCos:3.25 * rightCos;
console.log(.25 + 3.25 * leftCos);

//  character.skeleton.bones[10].rotation.z = 0;//-1 * rightCos;
//  character.skeleton.bones[8].rotation.z = -3;//leftCos;

  var delta = clock.getDelta();
    mixer.update(delta);
/*
index.html:134 We {x: 0.0398766, y: 1.44493, z: 0.127301}//身体
index.html:135 We {x: -1.07102e-8, y: 1.18078e-7, z: -0.204826}//尻尾つけね
index.html:136 We {x: -1.5425e-9, y: -9.13598e-8, z: -0.647774}//尻尾先
index.html:137 We {x: -1.07102e-8, y: 1.18078e-7, z: -0.204826}//左足つけね
index.html:138 We {x: -1.39698e-8, y: 1.10173e-7, z: -0.613065}//左足先
index.html:139 We {x: -1.07102e-8, y: 1.18078e-7, z: -0.204826}//右足付け根
index.html:140 We {x: -1.21072e-8, y: 4.092e-8, z: -0.615352}//右足先
index.html:141 We {x: -1.07102e-8, y: 1.18078e-7, z: -0.204826}//腰
index.html:142 We {x: 3.24445e-9, y: 3.6971e-9, z: -0.662118}//左肩
index.html:143 We {x: -1.86265e-9, y: -1.97051e-7, z: -0.339841}//左手
index.html:144 We {x: 3.24445e-9, y: 3.6971e-9, z: -0.662118}//右肩
index.html:145 We {x: -2.32831e-9, y: 6.4475e-8, z: -0.3863}//右手
*/
//console.log(arm.skeleton.bones[1].position)
    //console.log(arm.skeleton.bones[2].position)

//    arm.skeleton.bones[2].rotation.x = Math.sin(time * 0.002) * .5;
    renderer.render(scene, controlCamera);
    lastTime = time;

    oldLeftShoulderToElbow = nowLeftShoulderToElbow;
    oldRightShoulderToElbow = nowRightShoulderToElbow;
  }

  //animate()
}

init();




//----- ここから骨取得 -----//
const color = "aqua";
const lineWidth = 2;

async function setupCamera() {
    const video = document.getElementById('camera');
    video.width = videoWidth;
　  video.height = videoHeight;
    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        const stream = await navigator.mediaDevices.getUserMedia({
          'audio': false,
          'video': {
            facingMode: 'user',
            width: videoWidth,
            height: videoHeight}
        });
    video.srcObject = stream;
    
    return new Promise(resolve => {
      video.onloadedmetadata = () => {
        resolve(video);
      };
    });
    } else {
      const errorMessage = "This browser does not support video capture, or this device does not have a camera";
      alert(errorMessage);
      return Promise.reject(errorMessage);
  }
}


function takePicture(video, net) {
    const canvas = document.getElementById('camera-canvas');
    canvas.width = videoWidth;
    canvas.height = videoHeight;
    const ctx = canvas.getContext('2d');
    
    const imageScaleFactor = 0.5;
    const flipHorizontal = false;
    const outputStride = 16;
    const minPoseConfidence = 0.1;
    const minPartConfidence = 0.5;

    async function poseDetectionFrame() {
        let poses = [];
        var date = new Date();
        
        const pose = await net.estimateSinglePose(video, imageScaleFactor, flipHorizontal, outputStride);
        poses.push(pose);

        ctx.clearRect(0, 0, videoWidth, videoHeight);

        ctx.save();
// 鏡にしたい場合
//        ctx.scale(-1, 1);
//        ctx.translate(-videoWidth, 0);

// カメラ写す場合　今回は骨さえ取れればいいのでいらん
//        ctx.drawImage(video, 0, 0, videoWidth, videoHeight);

ctx.fillStyle = "rgb(200,0,0)";
ctx.fillRect(0,0,videoWidth,videoHeight);
        ctx.restore();


        // For each pose (i.e. person) detected in an image, loop through the poses
        // and draw the resulting skeleton and keypoints if over certain confidence
        // scores
        
        poses.forEach(({ score, keypoints }) => {
            if (score >= minPoseConfidence) {
              drawKeypoints(keypoints, minPartConfidence, ctx);
              drawSkeleton(keypoints, minPartConfidence, ctx);
          }
        });
    
    // End monitoring code for frames per second

        requestAnimationFrame(poseDetectionFrame);
    }

  poseDetectionFrame();
}

function drawKeypoints(keypoints, minConfidence, ctx, scale = 1) {
  for (let i = 0; i < keypoints.length; i++) {
    const keypoint = keypoints[i];

    if (keypoint.score < minConfidence) {
      continue;
    }

    if(keypoint.part == "rightShoulder"){rightShoulder = keypoint.position}
    if(keypoint.part == "rightElbow"){rightElbow = keypoint.position}
    if(keypoint.part == "rightWrist"){rightWrist = keypoint.position}

    if(keypoint.part == "leftShoulder"){leftShoulder = keypoint.position}
    if(keypoint.part == "leftElbow"){leftElbow = keypoint.position}
    if(keypoint.part == "leftWrist"){leftWrist = keypoint.position}

    if(keypoint.part == "rightHip"){rightHip = keypoint.position}
    if(keypoint.part == "leftHip"){leftHip = keypoint.position}

    nowRightShoulderToElbow = Math.sqrt(Math.pow(rightElbow.x - rightShoulder.x,2)+Math.pow(rightElbow.y - rightShoulder.y,2));
    nowLeftShoulderToElbow  = Math.sqrt(Math.pow(leftElbow.x - leftShoulder.x,2)+Math.pow(leftElbow.y - leftShoulder.y,2));
    if (rightElbow.y < rightShoulder.y) {
      nowRightShoulderToElbow = nowRightShoulderToElbow * -1;
    }
    if (leftElbow.y < leftShoulder.y) {
      nowLeftShoulderToElbow = nowLeftShoulderToElbow * -1;
    }

    if (keypoint.part == "rightHip"){
        s1 = (rightHip.x - leftShoulder.x) * (rightShoulder.y - leftShoulder.y) - (rightHip.y - leftShoulder.y) * (rightShoulder.x - leftShoulder.x)
        s2 = (rightHip.x - leftShoulder.x) * (leftShoulder.y - leftHip.y) - (rightHip.y - leftShoulder.y) * (leftHip.x - leftHip.x)
        centerBody =  rightShoulder.x + (leftHip.x - rightShoulder.x) * s1 / (s1 + s2), rightShoulder.y + (leftHip.y - rightShoulder.y) * s1 / (s1 + s2)
    }

    maxRightShoulderToElbow = (nowRightShoulderToElbow > maxRightShoulderToElbow) ? nowRightShoulderToElbow: maxRightShoulderToElbow;
    maxLeftShoulderToElbow = (nowLeftShoulderToElbow > maxLeftShoulderToElbow)? nowLeftShoulderToElbow : maxLeftShoulderToElbow;

    const { y, x } = keypoint.position;
    ctx.beginPath();
    ctx.arc(x * scale, y * scale, 3, 0, 2 * Math.PI);
    ctx.fillStyle = color;
    ctx.fill();

  }
}

function toTuple({ y, x }) {
  return [y, x];
}

function drawSkeleton(keypoints, minConfidence, ctx, scale = 1) {
  const adjacentKeyPoints = posenet.getAdjacentKeyPoints(
    keypoints, minConfidence);

  adjacentKeyPoints.forEach((keypoints) => {
    drawSegment(toTuple(keypoints[0].position),
      toTuple(keypoints[1].position), color, scale, ctx);
  });
}

function drawSegment([ay, ax], [by, bx], color, scale, ctx) {
  ctx.beginPath();
  ctx.moveTo(ax * scale, ay * scale);
  ctx.lineTo(bx * scale, by * scale);
  ctx.lineWidth = lineWidth;
  ctx.strokeStyle = color;
  ctx.stroke();
}

async function loadVideo() {
  const video = await setupCamera();
  video.play();

  return video;
}

async function main(){
    const net = await posenet.load();

    let video;
    video = await loadVideo();
    
    takePicture(video, net);
}

main();

  </script>
</html>